# C语言的深入学习

## ARM架构与汇编的简单阐述

### 汇编语言

​	汇编语言是一种低级编程语言，**它用于将人类可读的指令翻译成计算机可执行的机器指令**。

​	在计算机体系结构中，机器指令是计算机硬件能够直接执行的指令。每个计算机处理器都有其特定的机器指令集架构，包括一组特定的	指令和相应的操作码。汇编语言提供了一种直接编写这些机器指令的方式，**每个汇编语言指令都对应着一条特定的机器指令**。

### 常用汇编指令

- MOV 指令 - 用于移动或复制数据,例如 ：（mov eax, ebx 将ebx值复制到eax中）

- ADD 指令 - 用于对两个操作数进行加法运算,结果保存在第一个操作数中,例如 ：（add eax, ebx 将eax和ebx相加后结果保存在eax中）

- SUB指令-用于对两个操作数进行减法运算,结果保存在第一个操作数中，例如 ：（sub eax, ebx 将eax和ebx相加后结果保存在eax中）

- LDR 指令 - 用于从内存加载数据到寄存器中。例如:（LDR R0, addr ;将addr地址的内容加载到R0寄存器）

- STR 指令 - 将寄存器的值写入内存地址处。例如:（STR R0, [R1] ;将R0的值写入R1寄存器指向的内存地址处）

  



### ARM

​	ARM（Advanced RISC Machines）架构是一种广泛使用的**处理器架构**

## 变量

### 什么是变量：

**变量变量，就是存储数据的“容器”。变量一定是可读可写的，缺一不可。变量保存在内存中，每一个变量都有一个唯一的地址。**

**从汇编的角度来看其实就是使用LDR指令和STR指令对内存进行读写操作**，在单片机中读取变量需要使用LDR指令将内容加载到寄存器,写入变量需要使用STR指令从寄存器写入内存。

### 局部变量：

局部变量是指函数内定义的变量

在ARM架构下,局部变量可以理解为函数调用期间动态分配在**栈**中的内存,通过相对地址（基址寄存器+偏移）访问,并在函数结束后自动释放,这是它的一个重要属性。

### 全局变量：

从存储位置中去理解全局变量

- 全局变量会在程序的数据段中静态分配内存。
- 数据段是程序加载到内存后固定分配的区域,不会随函数调用变化。
- 全局变量的地址在程序编译与链接完成后就已经确定,不会动态改变。
- 与局部变量不同,全局变量不会在每次函数调用时重新分配内存。

### 静态变量：

静态变量是C/C++语言中的一个变量存储类,它在某些方面表现得像全局变量,在某些方面又像局部变量。

静态变量的主要特征是:

- 静态变量通过**static**关键字声明,可以是函数内或外部声明。
- **在函数内声明的静态变量,仅在对应函数内可见,但值在下次函数调用时保留。**
- 在函数外声明的静态变量等同于文件范围内的全局变量。
- 静态变量在程序运行期间内存位置不变,只分配一次内存。
- **不同源文件可以定义同名静态变量,但它们互不影响。**

### 常用关键字：

- volatile:
  修饰变量会告诉编译器每次访问这个变量都从内存中读取,而不是使用缓存的值,适用于访问设备寄存器等。

    举个例子：
  
  ```c
  int a；
  a=1; //从程序上来看这一步可以忽略，对应编译器不会直接去从内存中读取，加快程序的进行
  a=2;
  ```
  
  ```c
  volatile int a；
  a=1; //则编译器每次访问这个变量都从内存中读取
  a=2;
  ```
  
  
  
- const:
  修饰一个变量表示它的值不可以被修改。const修饰的全局变量在多个文件间可以看到。

- static:
  可用于修饰局部变量和全局变量:
  1. **修饰局部变量表示其作用域只在定义的函数内,值在函数调用间保留。**
  
     ```c
     void func() {
       static int count = 0; // 调用间count值保留
       count++;
     }
     ```
  
     
  
  2. **修饰全局变量表示其作用域只在当前编译单元(如源文件)内可见。**
  
- extern: 
  用于修饰变量声明,表示这个变量是在另一个文件定义的,且允许在当前文件引用它。

  ```c
  // file1.c
  int global; 
  
  // file2.c
  extern int global; // 引用file1定义的global
  ```
  
  extern可以和static一起使用:
  1) static extern变量在当前文件外部定义,但作用域只在当前文件内。
  2) extern static错误用法。

总之:

​	volatile用于特殊内存的访问优化	

​	const用于修饰不可修改的变量

​	static控制变量作用域和生命期

​	extern允许跨文件访问变量

它们都可以帮助我们更好地管理变量的使用。

## 函数

###  函数是什么：

​	**其本质就是一系列指令**

以下列这个函数来举例

```c
int add_val(int v)
{
    volatile int a = v;
    a++;
    return a;
}
```

以汇编的角度来看

```assembly
add_val:
    PUSH    {r4, lr}        ; 保存寄存器r4和链接寄存器lr到栈中
    MOV     r4, r0          ; 将参数v的值保存到寄存器r4中
    ADDS    r4, r4, #1      ; 将r4加1
    MOV     r0, r4          ; 将r4的值保存到返回值寄存器r0中
    POP     {r4, pc}        ; 从栈中恢复寄存器r4和链接寄存器lr，并跳转到调用者
```

我们在调用函数的过程中，其实就是让CPU的PC寄存器等于"一系列机器码""的首地址，也就是就是函数地址

## 结构体

结构体是C语言中的一种重要数据类型,它允许用户定义包含多个不同类型数据元素的自定义 data—type。

结构体变量的主要使用过程:

1. 声明结构体变量

```c
struct person ; // 声明结构体变量
```

2. 初始化结构体变量

```c
struct person = 
{
char a = "xiaohuang" ;
int b = 2 ;
     
}; 

```

3. 访问结构体成员

```c
person.a ; // 使用点运算符访问成员
person.b ; // 使用点运算符访问成员
```



## 指针

### 指针是什么：

​	**指针是一种变量类型**，用于存储内存地址。它指向（或引用）内存中的某个位置，允许我们通过地址来访问和操作内存中的数据。

通俗的来说：**指针指针，保存的是地址，32位处理器中地址都是32位的，无论是什么类型的指针变量，都是4字节**

下面我们通过keil5上面的软件仿真来验证来验证：

![image-20231130231228890](C:\Users\20215\AppData\Roaming\Typora\typora-user-images\image-20231130231228890.png)

![image-20231130231244657](C:\Users\20215\AppData\Roaming\Typora\typora-user-images\image-20231130231244657.png)

![image-20231130231335191](C:\Users\20215\AppData\Roaming\Typora\typora-user-images\image-20231130231335191.png)

可以明显看出来**无论是什么类型的指针变量，都是4字节**

这里强调一下

```c
//这三者的含义
int *p； 定义int型指针p
p；      //指的是指针代表是地址如0x0000001
*p      //表示通过p指针访问指向的int类型数据，但是由于p未初始化，它指向的内存地址现在是未定义的 

```

延申扩展**字节对齐**问题：

